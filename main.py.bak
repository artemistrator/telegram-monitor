import asyncio
import json
import os
import traceback
from typing import List, Dict, Optional
from fastapi import FastAPI, HTTPException, BackgroundTasks
from fastapi.responses import HTMLResponse, StreamingResponse
from pydantic import BaseModel
from telethon import TelegramClient, events
from telethon.errors import SessionPasswordNeededError
import aiohttp
import sys

# Configuration file
CONFIG_FILE = 'config.json'

# Monitoring functions

async def read_monitor_output():
    """Читать stdout и stderr monitor.py и логировать"""
    global monitor_process

    if not monitor_process:
        return

    try:
        # Читаем stdout и stderr параллельно
        async def read_stream(stream, prefix):
            if not stream:
                return
            try:
                async for line in stream:
                    # Декодируем с игнорированием ошибок для предотвращения UnicodeDecodeError
                    decoded = line.decode('utf-8', errors='replace').strip()
                    if decoded:
                        print(f"[MONITOR {prefix}] {decoded}")
            except Exception as e:
                print(f"[MONITOR {prefix}] Error reading stream: {e}")

        await asyncio.gather(
            read_stream(monitor_process.stdout, "OUT"),
            read_stream(monitor_process.stderr, "ERR"),
        )

    except Exception as e:
        print(f"Error reading monitor output: {e}")
        print(traceback.format_exc())

# Telegram client functions

async def check_session():
    """Проверить, существует ли сессия"""
    if os.path.exists('session.session'):
        return True
    return False

async def create_session():
    """Создать новую сессию"""
    if await check_session():
        raise HTTPException(status_code=400, detail="Session already exists")

    client = TelegramClient('session', api_id, api_hash)
    await client.start()

    if client.is_user_authorized():
        await client.disconnect()
        return {"message": "Session created successfully"}

    if client.is_code_requested():
        code = input("Enter the code you received: ")
        await client.sign_in(code=code)

    if client.is_password_requested():
        password = input("Enter your password: ")
        await client.sign_in(password=password)

    await client.disconnect()
    return {"message": "Session created successfully"}

async def connect_client():
    """Подключиться к Telegram"""
    if not await check_session():
        raise HTTPException(status_code=400, detail="Session does not exist")

    client = TelegramClient('session', api_id, api_hash)
    await client.start()

    if client.is_user_authorized():
        return client

    raise HTTPException(status_code=400, detail="Authorization failed")

async def fetch_messages(client, chat_id, limit=10):
    """Получить сообщения из чата"""
    messages = await client.get_messages(chat_id, limit=limit)
    return [message.message for message in messages]

async def handle_message(event):
    """Обработать входящее сообщение"""
    print(f"New message: {event.message.message}")

async def start_monitoring():
    """Запустить мониторинг"""
    global monitor_process

    if monitor_process:
        print("Monitor is already running")
        return

    monitor_process = await asyncio.create_subprocess_exec(
        'python', 'monitor.py',
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE,
    )

    asyncio.create_task(read_monitor_output())

async def stop_monitoring():
    """Остановить мониторинг"""
    global monitor_process

    if not monitor_process:
        print("Monitor is not running")
        return

    monitor_process.terminate()
    await monitor_process.wait()
    monitor_process = None

# FastAPI application

app = FastAPI()

@app.get("/")
async def read_root():
    return {"message": "Hello, World!"}

@app.post("/create_session")
async def create_session_endpoint():
    return await create_session()

@app.get("/fetch_messages/{chat_id}")
async def fetch_messages_endpoint(chat_id: int, limit: int = 10):
    client = await connect_client()
    messages = await fetch_messages(client, chat_id, limit)
    await client.disconnect()
    return messages

@app.post("/start_monitoring")
async def start_monitoring_endpoint():
    await start_monitoring()
    return {"message": "Monitoring started"}

@app.post("/stop_monitoring")
async def stop_monitoring_endpoint():
    await stop_monitoring()
    return {"message": "Monitoring stopped"}

# Load configuration

if os.path.exists(CONFIG_FILE):
    with open(CONFIG_FILE, 'r') as f:
        config = json.load(f)
        api_id = config.get('api_id')
        api_hash = config.get('api_hash')
else:
    raise Exception("Configuration file not found")

# Telegram client

client = TelegramClient('session', api_id, api_hash)

# Event handler

client.add_event_handler(handle_message, events.NewMessage)

# Start monitoring

monitor_process = None
